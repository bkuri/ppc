1. **Profile location: `profiles/` at repo root.**
   Keep profiles as “user presets,” not prompt modules. `prompts/` stays purely about composable behavior chunks; `profiles/` is composition config.

So:

```
profiles/
  ship.yml
  explore.yml
  build.yml
```

(and allow `--profiles-dir` later if needed)

---

2. **Profile scope: include compile semantics only (mode/traits/contract/revisions/vars), exclude diagnostics (`--explain`, `--hash`).**

Profiles should define what gets compiled, not how it’s displayed.

✅ include:

* `mode`
* `traits` (module IDs)
* `contract`
* `revisions`
* `vars` (optional)
* `prompts_dir` (optional; probably skip initially)

❌ exclude:

* `--explain`
* `--hash`
* output formatting knobs

Reason: keep profiles deterministic and portable; diagnostics are a user/session concern.

---

3. **Default profiles: yes, ship 3 defaults (`explore.yml`, `build.yml`, `ship.yml`).**

They should be *minimal*, showing best practice:

* `explore.yml`: creative + markdown + maybe verbose
* `build.yml`: conservative-ish + markdown
* `ship.yml`: conservative + terse + code + revisions=1

These become living examples and a quick “try it in 10 seconds” onboarding path.

---

4. **Merging behavior: flags override profile, but conflicts inside exclusive groups should still error.**

So the precedence is:

1. load profile → base config
2. apply CLI flags → overrides/additions
3. validate exclusive-group consistency → error if violated

Example:

* profile sets `traits/conservative` (`risk:low`)
* user adds `--creative` (`risk:high`)
* result: **conflict error** (because the rules should apply after merge)

This is the best of both worlds:

* predictable overrides
* still safe by construction

---

If you want a tight profile schema, I’d do:

```yaml
mode: ship
contract: code
revisions: 1
traits:
  - traits/conservative
  - traits/terse
vars: {}
```

Then CLI can accept:

* `--profile ship`
* `--profile ./profiles/custom.yml` (nice little bonus)
